***회원 도메인 협력 관계***

![image](https://user-images.githubusercontent.com/39082893/104602904-3271e780-56bf-11eb-9977-a5b4caee648d.png)
* 회원 저장소는 초기에 개발을 위해 java 메모리에 회원 정보를 저장한다.
* 기획자들도 볼 수 있는 그림이다.
---
***회원 클래스 다이어그램***

![image](https://user-images.githubusercontent.com/39082893/104604082-68fc3200-56c0-11eb-8fca-a4fc59623cff.png)

* MemberServiceImpl (Impl : Implement (구현))
* 위에서 구현체들(MemoryMemberRepo, DbMemberReop)은 동적으로 동작할 때 불러오는 것임.
* 즉, 실제 서버에서 어떤 구현체를 적용하는지 클래스 다이어그램에서는 확인이 불가 -> 객체 다이어그램에서 확인 가능 
---
***회원 객체 다이어그램***

![image](https://user-images.githubusercontent.com/39082893/104604535-cdb78c80-56c0-11eb-96bc-598b6e77f240.png)
* 실제 서버에 올라왔을 때 메모리간의 참조를 나타냄
* *회원 서비스 : MemberServiceImpl]
* 객체 다이어그램은 실제 구현체(Implementation)를 

## 느낌
우와...비즈니스 요구 사항에서 크게 두가지
회원가입
회원 조회
이렇게 주어졌다. 이는 회원이 실제로 이용할 수 있는 서비스.

이 서비스는 인터페이스로 먼저 역할을 잡고 구현한다.

그리고 **회원 서비스**는  **회원 저장소**를 참조하게 되는데 아직 회원 저장소는 **DB/외부 저장소** 중 어디에 구현할지 결정되지 않은 상태이다.
그래서 개발 당시에는 java 메모리에 임시로 구현하여 테스트를 진행한다.

기획을 할 때 클라이언트가 사용할 수 있는 기능들을 생각하고, 연관성 있는 기능들을 묶어 분류한다.
그리고 해당 서비스들을 사용하기 위해 무엇이 필요한지(저장소, 분석 툴 등등)를 결정하고, 이를 구현하기 위해 필요한 것들을 작성한다.

그러면 이것들은 **클래스 다이어그램**에서 **인터페이스**와 **구현체**로 나뉘어질 수 있고 실제 참조 관계는 **객체 다이어그램**을 통해 확인할 수 있다.

---
뭔가 진짜 일하는 느낌이 나서 재미있다 ㅋㅋㅋㅋ
