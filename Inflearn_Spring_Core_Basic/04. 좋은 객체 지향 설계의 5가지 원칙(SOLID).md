## SOLID 

### SRP - (Single responsibility principle)단일 책임 원칙
* 한 클래스는 하나의 책임만 가져야 한다.
* 기준 : **변경**
	* 변경이 있을 때 파급 효과가 적으면 단일 책임 원칙을 잘 따른 것이다.
* 적절하게 잘 조절하는 것이 객체지향설계의 묘미이다.

### OCP(Open/Closed principle) - 개방-폐쇄 원칙 * 가장 중요
* 소프트웨어 요소는 **확장에는 열려** 있으나 **변경에는 닫혀** 있어야 한다(?)
* **다형성**을 활용?
* **구현 객체를 변경하려면 클라이언트 코드를 변경**해야 한다.
![image](https://user-images.githubusercontent.com/39082893/104455300-70510c00-55ea-11eb-9227-9b1232a419d8.png)
* 다형성을 사용했지만 OCP 원칙을 지킬 수 없었다....
* 어떻게 해야 하나?
* 객체를 생성하고, 연관 관계를 맺어주는 별도의 조립, 설정자가 필요하고 이를 스프링이 해줄 것이다.
> 나중에 코드를 직접 짜보면서 아.. 이게 OCP구나 하고 알게 될 거라고 하신다.

### LSP(Liskov substitution principle) - 리스코프 치환 원칙
* 프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 한다.
* Ex) 자동차 인터페이스의 엑셀은 앞으로 가는 기능을 가지고 있다. 뒤로 가게 구현하면 LSP를 위반 한 것.
> 즉, 이 놈은 인터페이스가 가지는 고유한 기능을 침범하면 안된다는 의미이다.

### ISP(Interface segregation principle) - 인터페이스 분리 원칙
* 특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다.
* 적당한 크기로 잘 쪼개는 게 중요하다!
* 스프링 프레임워크도 엄청 철저하게 분리되어 있다.

### DIP(Dependency inversion principle) - 의존관계 역전 원칙 *가장 중요
* 프로그래머는 "추상화에 의존해야지, 구체화에 의존하면 안된다."
* 구현 <<<<<<<<<<<<<<<<<<<<<< 역할
![image](https://user-images.githubusercontent.com/39082893/104455300-70510c00-55ea-11eb-9227-9b1232a419d8.png)
* 위의 코드는 "MemoryMemberRepository()[구현 클래스]에 의존하고 있다.
	* MemberService 클라이언트가 구현 클래스를 직접 선택하고 있다.
	* DIP 위반

## 정리
* 객체 지향의 핵심은 다형성인데 다형성 만으로는 OCP / DIP를 지킬 수 없다.
* 다형성 만으로는 구현 객체를 변경할 때 클라이언트 코드도 함께 변경된다.
* 뭔가가 더 필요하다.

## 느낌
* SOLID는 객체 지향 설계를 할 때 기준이 되는 5가지 원칙을 의미한다.
* SRP - Single Repository Principle
	* 단일 책임 원칙
	* 변경이 발생했을때 그 파급 효과가 적어야 한다.
* *OCP - Open/Closed Principle
	* 개방 / 폐쇄 원칙
	* 확장에는 열려있으나 변경에는 닫혀있어야 한다.
	* 프로젝트를 확장시킬 수 잇어야 하나 확장을 위해 변경을 할 때는 바뀌면 안된다.
	* 다형성을 활용!
	* 하지만 맨바닥에서 확장을 하기 위해서는 클라이언트 코드를 무조오오건 변경해야 한다.
	* 즉, 다른 무언가가 더 필요하다.
* LSP - Liskov Substitution Principle
	* 인터페이스의 구현 클래스를 변경할 때 최종적인 기능은 동일해야 한다.
* ISP - Interface Segregation Principle
	* 인터페이스를 설계할 때 기능별로 잘 분리해서 설계해야 한다.
* *DIP - Dependency Inversion Principle
	* 의존 관계 역전 원칙
	* 구현 클래스 <<<<<<< 인터페이스
	* 구현 <<<<<< 역할
	* 프로그래머는 추상화에 의존해야지 구현에 의존해서는 안된다.
	* 이를 어길 시 Dependency Inversion!

이 중 가장 중요한 것이 OCP와 DIP인데 이를 가능하게 해주는 개념이 다형성이고 이 원칙을 지킬 수 있게 해주는 것이 스프링 프레임워크다!

